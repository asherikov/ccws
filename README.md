Introduction
============

`colcon` (https://colcon.readthedocs.io/) template workspace for ROS
development and testing. This template integrates functionalities of
traditional workspaces and CI pipelines.


Features
--------

- Build profiles -- sets of configurations for build process, e.g., cmake
  toolchain, colcon configuration, environment variables, etc. Profiles do not
  conflict with each other and can be used simultaneously without using
  separate clones of the workspace and packages.

- Documentation generation for the whole workspace using `doxygen`, similar to
  https://github.com/mikepurvis/catkin_tools_document, but `doxygen`
  configuration and index html page are exposed and kept in the workspace.
  Example -> https://asherikov.github.io/ccws/example_staticoma/index.html

- Various static checks as in https://github.com/sscpac/statick, but with more
  flexibility (see `make/static_checks.mk`), in particular:
    - `cppcheck`
    - `catkin_lint` https://github.com/fkie/catkin_lint
    - `yamllint`
    - `shellcheck`
    - `clang-tidy` and `scan_build` via build profile, see below.

- Package template which demonstrates how to use some of the features.

- The number of parallel jobs can be selected based on available RAM instead of
  CPU cores, since RAM is more likely to be the limiting factor.

- Based entirely on `make` and shell scripts. All scripts are kept in the
  workspace and easy to adjust for specific needs.

- Cross-compilation support.

- Binary debian package generation.


Profiles
--------

Profile configurations are located in `profiles`, currently availabale profiles are
- `reldebug` -- default profile, default compiler, cmake build type is
  `RelWithDebInfo`
- `scan_build` -- static checks with `scan_build` and `clang-tidy`.
  `clang-tidy` parameters are defined in cmake toolchain and must be enabled in
  packages as shown in package template. This profile also uses `clang` compiler.
- `thread_sanitizer` -- compilation with thread sanitizer.
- `addr_undef_sanitizers` -- compilation with address and undefined behavior
  sanitizers.
- `cross_raspberry_pi` -- cross-compilation for Raspberry Pi.
- `cross_jetson_xavier` -- cross-compilation for Jetson Xavier.

All profiles use `ccache`, but it can be disabled in cmake toolchains.

`common` subdirectory contains default parameters, which may be overriden by
build profiles.


Dependencies
------------

### Required
- `colcon`
- `wstool` -- it provides much more advanced features than `vcstool` which does
  not maintain package states locally.
- `cmake`

See `wsinstall_*` targets in `Makefile` for more info.


### Optional
- `doxygen`
- static checkers, see `install_static_checkers` target in `make/static_checks.mk`
- `ccache`


### `scan_build` profile

`clang`, `scan_build` and `clang-tidy` for `scan_build` profile:
- apt install clang-tools-10 clang-tidy-10 clang-10



Usage
=====

Demo workspace is available in a branch of this repository ->
https://github.com/asherikov/ccws/tree/example_staticoma


Initial setup
-------------

- Edit `make/config.mk` and `profiles/common/config.bash` to specify
  developer-dependent worskpace parameters.
- Install dependencies using `wsinstall_*` targets or manually, see
  `make/dep_install.mk` for available targets.
- Clone packages in `src` subdirectory, or create new using `make new PKG=<pkg>`.


Compilation
-----------

- `make build PKG="<pkg>"` where `<pkg>` is one or more space separated package names.
- `make <pkg>` -- a shortcut for `make build`, but the `<pkg>` can be a
  substring of package name. All packages matching the given substring will be built.
- The number of jobs can be overriden with `JOBS=X` parameter.
- `make build PKG=<pkg> PROFILE=scan_build` overrides default profile.


Running
-------

- Source `profiles/<profile>/setup.bash` to be able to use packages. Setup
  scripts generated by `colcon` can also be used directly, e.g.,
  `install/<profile>/setup.sh`, but in this case some of the workspace
  functionality won't be available.


Testing
-------
- `make test PKG=<pkg>` test with `colcon`.
- `make ctest PKG=<pkg>` bypass colcon and run `ctest` directly.


Documentation
-------------
- `make doxall`, `firefox artifacts/doxygen/index.html`


Cross-compilation (Raspberry Pi)
--------------------------------

Make sure that global dependencies are installed first (described above).

1. install profile dependencies with `make install PROFILE=cross_raspberry_pi`
2. clone your repos to `src`, e.g., `cd src; git clone https://github.com/asherikov/staticoma.git`
3. add your repos to the workspace `make wsscrape`
4. add ROS dependencies of all your packages to the workspace `make wsdep_to_rosinstall`,
   or a specific package `make dep_to_rosinstall PKG=<pkg>`
5. fetch all packages `make wsupdate`
6. mount sysroot with `make cross_raspberry_pi_mount` (see `profiles/cross_raspberry_pi/targets.mk`)
7. install system dependencies to the image `make cross_dep_install PKG=staticoma PROFILE=cross_raspberry_pi`
8. build packages, e.g. `make staticoma PROFILE=cross_raspberry_pi` or build
   and generate deb package `make deb PKG=staticoma PROFILE=cross_raspberry_pi`
9. unmount sysroot when done with `make cross_raspberry_pi_umount`

See `doc/cross-compilation.md` for more details.


Cross-compilation (Jetson Xavier)
---------------------------------
Make sure that global dependencies are installed first (described above).

This profile requires Ubuntu 18.04, installs CUDA and some other NVIDIA stuff,
you may want to do this in a docker. Currently works only for ROS melodic.

1. Copy APP partition image to `profiles/cross_xavier_jetson/system.img`
2. Install profile dependencies with `make install PROFILE=cross_jetson_xavier`
3. clone your repos to `src`, e.g., `cd src; git clone https://github.com/asherikov/staticoma.git`
4. add your repos to the workspace `make wsscrape`
5. add ROS dependencies of all your packages to the workspace `make wsdep_to_rosinstall`,
   or a specific package `make dep_to_rosinstall PKG=<pkg>`
6. fetch all packages `make wsupdate`
7. mount sysroot with `make cross_jetson_xavier_mount` (see `profiles/cross_jetson_xavier/targets.mk`)
8. install system dependencies to the image `make cross_dep_install PKG=staticoma PROFILE=cross_jetson_xavier`
9. build packages, e.g. `make staticoma PROFILE=cross_jetson_xavier` or build
   and generate deb package `make deb PKG=staticoma PROFILE=cross_jetson_xavier`
10. unmount sysroot when done with `make cross_jetson_xavier_umount`


Debian package generation
-------------------------

### Overview

`CCWS` takes a rather uncommon approach to binary package generation which is a
middle ground between traditional ROS approach (1 package = 1 deb) and docker
containers: all packages built in the workspace are packaged together into a
single debian 'superpackage'. It is assumed that base ROS packages are included
in the workspace, although it is not strictly necessary.

This approach has a number of advantages:

- Binary compatibility issues are minimized compared to traditional ROS
  approach:
    - no need to worry about compatibilities between multiple small standalone
      binary packages and perform ABI checks;

    - if ROS packages are included, it is also possible to avoid binary
      incompatibilities between syncs of the same ROS release (those actually
      happen) and be able to use old packages incompatible with the latest
      sync.

- This approach allows for somewhat sloppier package management compared to ROS
  when it comes to tags, versions, etc, e.g., there is no need to maintain
  release repos for all packages. In this sense `CCWS` facilitates 'rolling
  releases' / 'continuous delivery' approach to development.

- Debian 'superpackages' are easier to manage than both standalone packages and
  docker containers, e.g. they can be generated by developers from their
  working branches and easily copied over network to be installed on the
  target;

- Debian packages have some advantages over docker in general as well:
    - Zero overhead during execution.

    - Straightforward access to hardware.

    - Easy installation of system services, udev rules, configs, etc.


### Building packages

In order to get all paths right in ROS cmake files we have to install to the
host root, we avoid this using bind mounts, which are automatic in
cross-compilation profiles, but need to be performed explicitly in the case of
'native' builds, e.g.
- `make deb_mount PKG=staticoma PROFILE=reldebug`
- `make deb PKG=staticoma PROFILE=reldebug`
- `make deb_umount PKG=staticoma PROFILE=reldebug`
- or simply `make deb_native PKG=staticoma PROFILE=reldebug`


TODO:
- We dont need cmake paths to be correct in a superpackage unless some other
  software is going to be built using it. A simplified procedure can be
  implemented.
- Native builds can also be performed in a docker container to avoid messing up
  with the system.


Related software
================

Related projects:
- https://github.com/ros-industrial/industrial_ci
- https://github.com/git-afsantos/haros
- https://github.com/DLu/roscompile
- https://github.com/asherikov/catkin_workspace [deprecated]
- https://github.com/ros-tooling/cross_compile/
- https://github.com/mikepurvis/catkin_tools_document
