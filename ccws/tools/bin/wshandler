#!/usr/bin/env bash
#!/usr/bin/bash -x
# shellcheck disable=SC2317,SC2329

set -Ee
set -o pipefail

WSH_VERSION=

wsh_echo()
{
    test "${WSH_QUIET}" = "YES" || echo "WSH:" "$@"
}

wsh_exit()
{
    wsh_echo "$2"
    exit "$1"
}

help()
{
    EXIT_CODE=${1:-"0"}
    wsh_echo "Usage (default values are shown in curly braces):"
    wsh_echo "  wshandler [<COMMON_ARGS>] [<COMMAND_ARGS>] <COMMAND> <COMMAND_ARGS>"
    test -z "${WSH_VERSION}" || wsh_echo "  wshandler -v|--version"
    wsh_echo ""
    wsh_echo "Notation:"
    wsh_echo "  <REQUIRED ARGUMENT>"
    wsh_echo "  {DEFAULT VALUE}"
    wsh_echo "  [OPTIONAL ARGUMENT]"
    wsh_echo "  (VALID OPTIONS IN A LIST)"
    wsh_echo ""
    wsh_echo "Common arguments:"
    wsh_echo "  -y|--yaml_tool auto|gojq|yq    {auto}               # Use gojq or yq, auto prefers gojq"
    wsh_echo "  -Y|--yaml_binary <BINARY_PATH> {yq|gojq}            # Override yaml tool (yq/gojq) path"
    wsh_echo "  -r|--root <WORKSPACE_ROOT>     {./}                 # Parent of --list if it is a path"
    wsh_echo "  -c|--cache <CACHE_DIR>         {<WORKSPACE_ROOT>}   # Temporary files created here"
    wsh_echo "  -t|--type rosinstall|repos     {repos}              # Repository list format"
    wsh_echo "  -i|--indent 1|2|3...           {4}                  # Default indentation in yaml repository list"
    wsh_echo "  -k|--keep-going                {false}              # Do not stop on errors"
    wsh_echo "  -l|--list <FILENAME>           {.rosinstall|.repos} # Default depends on --type,"
    wsh_echo "                                                      #can be specified multiple times,"
    wsh_echo "                                                      #mutually exclusive with -L"
    wsh_echo "  -L|--list-discover                                  # Automatically discover lists in the root,"
    wsh_echo "                                                      #recursively searches for *.<type> files,"
    wsh_echo "                                                      #mutually exclusive with -l,"
    wsh_echo "                                                      #should be set after -r and -t."
    wsh_echo "  -T|--tag <TAG>                 {}                   # Filter repositories by tags"
    wsh_echo "                                                      #can be specified multiple times"
    wsh_echo "  -q|--quiet                                          # Suppress most of the output"
    wsh_echo ""
    wsh_echo "Repository list commands:"
    wsh_echo "  Information:"
    wsh_echo "    [-u|--unsorted] status    # show workspace status"
    wsh_echo "    is_source_space           # check if a directory is a workspace"
    wsh_echo ""
    wsh_echo "  Initialization:"
    wsh_echo "    Common arguments:"
    wsh_echo "      [-p|--policy <POLICY1[,POLICY2]> ({default}|shallow|nolfs)]"
    wsh_echo "        default   # plain clone"
    wsh_echo "        shallow   # shallow clone"
    wsh_echo "        nolfs     # disable git LFS"
    wsh_echo "    clone git <LIST_REPOSITORY> [<BRANCH>]    # clone workspace from a given repository"
    wsh_echo "    init [git <PACKAGE_REPOSITORY> ...]       # initialize new workspace"
    wsh_echo ""
    wsh_echo "  Modification:"
    wsh_echo "    [-p|--policy {ask}|add|show|clean] scrape <DIRECTORY {<WORKSPACE_ROOT>}>  # process unmanaged repositories"
    wsh_echo "      ask         # interactive mode"
    wsh_echo "      add         # automaticaly add repositories"
    wsh_echo "      show        # show unmanaged repositories"
    wsh_echo "      clean       # remove unmanaged repositories"
    wsh_echo "    add git <PACKAGE_NAME> <PACKAGE_URL> <PACKAGE_VERSION>    # add a repository"
    wsh_echo "    set_version_by_url <PACKAGE_URL> <PACKAGE_VERSION>        # set repository version"
    wsh_echo "    set_version_by_name <PACKAGE_NAME> <PACKAGE_VERSION>      # set repository version"
    wsh_echo "    set_version_to_hash                                       # set all repository versions to hash"
    wsh_echo "    pin                                                       # alias for set_version_to_hash"
    wsh_echo "    [-p|--policy <POLICY1[,POLICY2]> ({active})] set_version_to_branch <BRANCH_NAME>  # change to the given branch"
    wsh_echo "      active      # switch if the given branch is checked out"
    wsh_echo "    remove <PACKAGE_NAME> ...                                 # remove repository from a list"
    wsh_echo "    remove_by_url <PACKAGE_URL> [<PACKAGE_URL>]               # remove repository from a list"
    wsh_echo "    [-p|--policy {keep}|replace] merge <LIST_FILENAME>        # merge repository list"
    wsh_echo "      keep        # keep original entries when there is a collision"
    wsh_echo "      replace     # replace entries when there is a collision"
    wsh_echo ""
    wsh_echo "Repository commands:"
    wsh_echo "  Selective commands (<PACKAGE_NAME> may be a pattern):"
    wsh_echo "    Common arguments:"
    wsh_echo "      [-j|--jobs <NUM_THREADS> {1}]       # use multiple jobs if possible"
    wsh_echo "      [-U|--unmanaged]                    # work on unmanaged repository directories: directory names must"
    wsh_echo "                                          #be given instead of package names, at least one is required,"
    wsh_echo "                                          #ignores --jobs"
    wsh_echo "    clean [<PACKAGE_NAME> ...]            # remove repository"
    wsh_echo "    prune [<PACKAGE_NAME> ...]            # git prune"
    wsh_echo "    push [<PACKAGE_NAME> ...]             # git push"
    wsh_echo "    unshallow [<PACKAGE_NAME> ...]        # git unshallow"
    wsh_echo "    feature_branches [<PACKAGE_NAME> ...] # list git feature branches"
    wsh_echo "    [-p|--policy <POLICY1[,POLICY2]> update [<PACKAGE_NAME> ...] # git pull"
    wsh_echo "      default      # plain clone"
    wsh_echo "      shallow      # shallow clone"
    wsh_echo "      nolfs        # disable git LFS"
    wsh_echo "      rebase       # do git pull with rebase"
    wsh_echo "      unmodified   # only unmodified repos"
    wsh_echo "      nosubmodules # do not checkout submodules"
    wsh_echo "      origin       # check origin URL matches list, remove and reclone if mismatch"
    wsh_echo ""
    wsh_echo "  Generic commands:"
    wsh_echo "    [-j|--jobs <NUM_THREADS> {1}] foreach git '<COMMAND>'  # execute command in each repository"
    wsh_echo ""
    wsh_echo "  Branching commands:"
    wsh_echo "    branch show ['<GREP_PATTERN>']                    # show matching branches"
    wsh_echo "    branch new <BRANCH_NAME>                          # create a new branch in modified repositories"
    wsh_echo "    branch allnew <BRANCH_NAME>                       # create a new branch in all repositories"
    wsh_echo "    branch delete <BRANCH_NAME>                       # delete branch from all repositories"
    wsh_echo "    branch merge <BRANCH_NAME> <TARGET_BRANCH {main}> # merge brach"
    wsh_echo "    commit '<MESSAGE>'                                # commit to modified repositories"
    wsh_echo ""
    wsh_echo "wshandler installation commands:"
    wsh_echo "  install_test_deps                                                           # install test dependeincies"
    wsh_echo "  [-p|--policy {skip_yaml_tool}|snap|download|apt] install <BIN_PATH {~/bin}> # install wshandler"
    wsh_echo "      skip_yaml_tool  # do not install yaml tool"
    wsh_echo "      snap            # install yaml tool (jq) using snap"
    wsh_echo "      download        # download yaml tool (jq)"
    wsh_echo "      apt             # install yaml tool (gojq) using apt"
    wsh_echo "  upgrade <BIN_PATH {~/bin}>              # upgrade wshandler"
    wsh_echo "  upgrade_appimage <BIN_PATH {~/bin}>     # upgrade wshandler AppImage"

    exit "${EXIT_CODE}"
}


update_root()
{
    IFS=',' read -ra POLICIES <<< "${WSH_COMMAND_POLICY}"

    if [ -d "${WSH_WORKSPACE_ROOT}/.git" ]
    then
        pushd "${WSH_WORKSPACE_ROOT}" > /dev/null
        if [ -n "$(git remote show)" ]
        then
            wsh_echo "Processing workspace root ${WSH_WORKSPACE_ROOT}"
            git fetch
            if git diff --exit-code > /dev/null && git diff --cached --exit-code > /dev/null
            then
                # if we are on a branch make sure that it is updated
                if (git branch --show-current | grep "${REPO_VERSION}")
                then
                    PULL_ENV=(env)
                    PULL_ARGS=()
                    for POLICY in "${POLICIES[@]}";
                    do
                        case ${POLICY} in
                            rebase) PULL_ARGS+=(--rebase);;
                            nolfs)  PULL_ENV+=("GIT_LFS_SKIP_SMUDGE=1");;
                        esac
                    done
                    # do not fail, e.g., the branch might be deleted from git remote
                    "${PULL_ENV[@]}" git pull "${PULL_ARGS[@]}" || true
                fi
            fi
        fi
        popd > /dev/null
    fi
}

git_scrape()
{
    SCRAPE_ROOT=$(realpath "$1")
    FIND_ARGS=()
    if [ "${WSH_WORKSPACE_ROOT}" -ef "${SCRAPE_ROOT}" ]
    then
        FIND_ARGS+=(-mindepth 2)
    fi
    REPO_DIRS=$(cd "${SCRAPE_ROOT}" && find ./ "${FIND_ARGS[@]}" -type d -name ".git" | sed -e 's|^./||' -e "s|/.git$||" | sort)
    UNKNOWN_REPO_DIRS=$(comm -2 -3 <(echo "${REPO_DIRS}" | tr ' ' '\n') <("${WSH_WORKSPACE_TYPE}_${WSH_YAML_TOOL}_repo_tuples" git < "${WSH_REPOLIST}" | cut -f 1 -d ' ' | sort))

    for REPO_DIR in ${UNKNOWN_REPO_DIRS}
    do
        wsh_echo "Processing ${REPO_DIR}"
        ABSOLUTE_REPO_DIR="${SCRAPE_ROOT}/${REPO_DIR}"
        pushd "${ABSOLUTE_REPO_DIR}" > /dev/null
        REPO_URL=$(git remote get-url origin | tr -d '\n' || true)

        if [ "${REPO_URL}" == "" ]
        then
            REPO_URL=$(pwd)
        fi

        REPO_VERSION=$(git branch --show-current | tr -d '\n')
        REPO_VERSION=${REPO_VERSION:-"$(git describe --tags | tr -d '\n')"}
        REPO_VERSION=${REPO_VERSION:-"$(git rev-parse --verify HEAD | tr -d '\n')"}

        popd > /dev/null

        echo "Found unmanaged git repository:  ${REPO_DIR}  ${REPO_URL}  ${REPO_VERSION}"

        case "${WSH_COMMAND_POLICY}" in
            ask|default)
                while [ -z "${ACTION}" ]
                do
                    read -r -p "Add (y or a (default)), do nothing (n), remove (c): " yn
                    yn=${yn:-"Y"}
                    case $yn in
                        [YyAa]) ACTION=add;;
                        [Nn])   ACTION=show;;
                        [Cc])   ACTION=clean;;
                        *)      echo "Please enter one of y/n/c.";;
                    esac
                done;;
            show|add|clean)
                ACTION="${WSH_COMMAND_POLICY}";;
            *)
                help 20;;
        esac

        case ${ACTION} in
            add)    execute_add git "${REPO_DIR}" "${REPO_URL}" "${REPO_VERSION}";;
            clean)  rm -rf "${ABSOLUTE_REPO_DIR}";;
        esac

        ACTION=""
    done
}

git_clone()
{
    SPARSE=$1
    REPO_URL=$2
    VERSION=$3
    DIR=$4

    GIT=(env)
    for POLICY in "${POLICIES[@]}";
    do
        case ${POLICY} in
            # --no-tags -- we need tags
            # --single-branch -- implied by --depth
            shallow)      CLONE_ARGS+=(--depth 1 --shallow-submodules);;
            nolfs)        GIT+=("GIT_LFS_SKIP_SMUDGE=1");;
            nosubmodules) SUBMODULES=NO;;
        esac
    done
    GIT+=("git")

    if [ "${SUBMODULES}" != "NO" ]
    then
        CLONE_ARGS+=(--recurse-submodules)
    fi
    if [ "${SPARSE}" = "YES" ]
    then
        CLONE_ARGS+=(--sparse)
    fi

    SOURCE_DESTINATION=("${REPO_URL}")
    if [ -n "${DIR}" ]
    then
        SOURCE_DESTINATION+=("${DIR}")
    fi

    if [ "${VERSION}" == '-' ] || [ -z "${VERSION}" ]
    then
        "${GIT[@]}" clone "${CLONE_ARGS[@]}" "${SOURCE_DESTINATION[@]}"
    else
        if ! ("${GIT[@]}" clone "${CLONE_ARGS[@]}" --branch "${VERSION}" "${SOURCE_DESTINATION[@]}")
        then
            # REPO_VERSION is a hash
            # clone with history to be able to find it
            "${GIT[@]}" clone "${SOURCE_DESTINATION[@]}"

            pushd "${DIR}" > /dev/null
            wsh_echo "Checking out '${VERSION}' in '$(pwd)'"

            "${GIT[@]}" checkout "${VERSION}"
            if [ "${SUBMODULES}" != "NO" ]
            then
                "${GIT[@]}" submodule update --init --recursive --jobs "${WSH_JOBS}"
            fi

            popd > /dev/null
        fi
    fi
}

dir_git_uncommitted()
{
    git status --porcelain | grep . > /dev/null
}

dir_git_get_hash()
{
    git rev-parse --verify HEAD
}

dir_git_get_branch()
{
    git rev-parse --verify --abbrev-ref HEAD
}

dir_git_status()
{
    NAME="$1"
    REPO_DIR="${WSH_WORKSPACE_ROOT}/$1"
    REPO_URL="$2"
    REPO_VERSION="$3"

    GIT_ACTUAL_VERSION="-"
    GIT_ACTUAL_HASH="-"
    if [ -d "${REPO_DIR}/.git" ]
    then
        cd "${REPO_DIR}"
        REPO_VERSION_HASH=$(git rev-parse --verify "${REPO_VERSION}^{commit}" 2> /dev/null || echo -n "-")
        GIT_ACTUAL_VERSION=$(git describe --dirty --broken --all --long --always | tr -d '\n' || echo -n "-")
        GIT_ACTUAL_HASH=$(dir_git_get_hash || echo -n "-")
    fi

    FLAGS=""
    if [ "${REPO_VERSION_HASH}" = "${GIT_ACTUAL_HASH}" ]
    then
        FLAGS+=" "
    else
        if [ "${REPO_VERSION_HASH}" = "-" ] || [ "${GIT_ACTUAL_HASH}" = "-" ]
        then
            FLAGS+="?"
        else
            FLAGS+="H"
        fi
    fi

    if [ "${GIT_ACTUAL_HASH}" != "-" ] && dir_git_uncommitted;
    then
        FLAGS+="M"
    else
        FLAGS+=" "
    fi

    echo "${NAME}|${REPO_VERSION}|${GIT_ACTUAL_VERSION}|${FLAGS}|${REPO_URL}"
}


dir_git()
{
    wsh_echo "Performing '$1' on '$2'"
    REPO_DIR="${WSH_WORKSPACE_ROOT}$2"
    dir_git_assert "${REPO_DIR}"

    pushd "${REPO_DIR}" > /dev/null
    case $1 in
        unshallow)
            if git fetch --unshallow
            then
                git config remote.origin.fetch "+refs/heads/*:refs/remotes/origin/*"
                git fetch origin
            fi
            ;;
        feature_branches)
            git for-each-ref --sort=committerdate --format='%(committerdate) %09 %(authorname) %09 %(refname)' \
                | (grep 'refs/remotes/' | grep -v '\(/main\)\|\(/master\)\|\(/release\)\|\(/gh-pages\)\|\(/HEAD\)' || true)
            ;;
        prune)  git remote | xargs --no-run-if-empty -I {} git remote prune {};;
        push)   git push;;
    esac
    popd > /dev/null
}


dir_git_update()
{
    NAME=$1
    REPO_DIR="${WSH_WORKSPACE_ROOT}$1"
    REPO_URL="$2"
    REPO_VERSION="$3"

    mkdir -p "${REPO_DIR}"

    wsh_echo "updating '$1'."

    pushd "${REPO_DIR}" > /dev/null
    IFS=',' read -ra POLICIES <<< "${WSH_COMMAND_POLICY}"

    GIT=(env)
    PULL_ARGS=()
    for POLICY in "${POLICIES[@]}";
    do
        case ${POLICY} in
            unmodified)   UNMODIFIED=YES;;
            nosubmodules) SUBMODULES=NO;;
            nolfs)        GIT+=("GIT_LFS_SKIP_SMUDGE=1");;
            rebase)       PULL_ARGS+=(--rebase);;
            origin)       ORIGIN=YES;;
        esac
    done
    GIT+=("git")

    SPARSE=NO
    IFS='.' read -ra GIT_VERSION <<< "$(git version | grep -o '[0-9]*\.[0-9]*\.[0-9]')"
    if [ "${GIT_VERSION[0]}" -ge 2 ] || { [ "${GIT_VERSION[0]}" -eq 2 ] && [ "${GIT_VERSION[1]}" -ge 25 ]; }
    then
        SPARSE_PATHS=()
        readarray -t SPARSE_PATHS <<< "$("${WSH_WORKSPACE_TYPE}_${WSH_YAML_TOOL}_sparse" "${NAME}" "${WSH_REPOLISTS[0]}")" || true
        if [ ${#SPARSE_PATHS[@]} -ge 1 ] && [ "${SPARSE_PATHS[0]}" != "" ]
        then
            SPARSE=YES
        fi
    fi

    if [ ! -d ".git" ]
    then
        rm -rf "${REPO_DIR:?}/*"
        git_clone "${SPARSE}" "${REPO_URL}" "${REPO_VERSION}" "./"
        CLONED=YES
    else
        # Check if origin policy is enabled and if URL matches
        if [ "${ORIGIN}" = "YES" ]
        then
            CURRENT_ORIGIN_URL=$(git remote get-url origin 2>/dev/null || echo "")
            if [ "${CURRENT_ORIGIN_URL}" != "${REPO_URL}" ]
            then
                wsh_echo "Origin URL mismatch for '$1': expected '${REPO_URL}', got '${CURRENT_ORIGIN_URL}'"
                find ./ -maxdepth 1 -mindepth 1 -exec rm -rf {} \;
                git_clone "${SPARSE}" "${REPO_URL}" "${REPO_VERSION}" "./"
                CLONED=YES
            fi
        fi
    fi

    if [ "${CLONED}" != "YES" ] || [ "${SPARSE}" = "YES" ]
    then
        if [ "${SPARSE}" = "YES" ]
        then
            test "${REPO_VERSION}" == '-' || "${GIT[@]}" sparse-checkout set "${SPARSE_PATHS[@]}"
        fi

        if [ "${UNMODIFIED}" = "YES" ]
        then
            REPO_VERSION_HASH=$(git rev-parse --verify "${REPO_VERSION}^{commit}" 2> /dev/null || echo -n "-")
            GIT_ACTUAL_HASH=$(dir_git_get_hash || echo -n "-")

            if [ "${GIT_ACTUAL_HASH}" != "-" ];
            then
                if [ "${REPO_VERSION_HASH}" != "${GIT_ACTUAL_HASH}" ] || dir_git_uncommitted;
                then
                    wsh_echo "Skipping modified '${REPO_DIR}'."
                    popd > /dev/null
                    return;
                fi
            fi
        fi

        "${GIT[@]}" fetch
        if git diff --exit-code > /dev/null && git diff --cached --exit-code > /dev/null
        then
            if [[ $(git branch -a | wc -l) -ne 0 ]]; # if no branches do nothing
            then
                if [ "${REPO_VERSION}" != '-' ]
                then
                    "${GIT[@]}" checkout "${REPO_VERSION}"
                    if [ "${SUBMODULES}" != "NO" ]
                    then
                        "${GIT[@]}" submodule update --init --recursive --jobs "${WSH_JOBS}"
                    fi
                fi

                # if we are on a branch make sure that it is updated
                if [ "${REPO_VERSION}" == '-' ] || (git branch --show-current | grep "${REPO_VERSION}")
                then
                    "${GIT[@]}" pull "${PULL_ARGS[@]}"
                fi
            fi
        fi
    fi
    popd > /dev/null
}

dir_git_merge()
{
    NAME=$1
    BRANCH=$2
    TARGET_BRANCH=$3

    cd "${WSH_WORKSPACE_ROOT:?}/${NAME}";
    if [ "${BRANCH}" = "$(dir_git_get_branch)" ]
    then
        if dir_git_uncommitted
        then
            wsh_exit 30 "Uncommited changes detected in '${NAME}'"
        fi

        if ! git rev-parse --verify "${TARGET_BRANCH}" 2> /dev/null
        then
            wsh_exit 31 "No target branch '${TARGET_BRANCH}' in '${NAME}'"
        fi

        git checkout "${TARGET_BRANCH}"
        git merge "${BRANCH}"
    fi
}

dir_git_assert()
{
    test -d "$1/.git" || wsh_exit 40 "${NAME}: is not a git repository'"
}


dir_git_clean()
{
    REPO_DIR="${WSH_WORKSPACE_ROOT}$1"
    if [ ! -d "${REPO_DIR}" ]
    then
        echo "Cannot remove missing '${REPO_DIR}'";
    else
        rm -rf "${REPO_DIR}";
    fi
}


status()
{
    SOURCE_TYPE=$1

    DATA=$(
        if [ "${WSH_QUIET}" = "NO" ]
        then
            echo "name|version|actual version|HM|repository";
            echo "----|-------|--------------|--|----------";
        fi
        "${WSH_WORKSPACE_TYPE}_${WSH_YAML_TOOL}_repo_tuples" "${SOURCE_TYPE}" < "${WSH_REPOLIST}" | while read -r -a tuple; do "dir_${SOURCE_TYPE}_status" "${tuple[@]}"; done | "${WSH_SORT_COMMAND}"
    )

    FORMAT_STRING=""
    for i in {1..4};
    do
        MAX_LEN=$(cut -f "$i" -d '|' <<< "${DATA}" | wc -L | grep -o "[0-9]*")
        if [ "$i" != "1" ]
        then
            FORMAT_STRING+=" "
        fi
        FORMAT_STRING+="%-${MAX_LEN}.${MAX_LEN}s"
    done

    if [ "${WSH_QUIET}" = "NO" ]
    then
        echo "Flags: H - version hash mismatch, M - uncommited changes"
    fi

    IFS=$'\n' readarray -t ROWS <<< "${DATA}"
    for ROW in "${ROWS[@]}"
    do
        IFS='|' read -ra COLS <<< "${ROW}"
        # use ${COLUMNS} to crop?
        # shellcheck disable=SC2059
        printf "${FORMAT_STRING} %s\n" "${COLS[@]}"
    done

    if [ "${WSH_QUIET}" = "NO" ]
    then
        echo

        WSH_COMMAND_POLICY=show
        scrape "${SOURCE_TYPE}" "${WSH_WORKSPACE_ROOT}"
    fi
}

scrape()
{
    "$1_scrape" "${@:2}"
}

initialize_yaml_tool()
{
    if [ "${WSH_YAML_TOOL}" = "auto" ]
    then
        YAML_TOOL_LIST=(gojq yq)
    else
        YAML_TOOL_LIST=("${WSH_YAML_TOOL}")
    fi

    for YAML_TOOL in "${YAML_TOOL_LIST[@]}"
    do
        WSH_YAML_TOOL="${YAML_TOOL}"
        if command -v "${WSH_YAML_BINARY}" > /dev/null
        then
            break
        fi

        WSH_YAML_BINARY="${YAML_TOOL}"
        if command -v "${WSH_YAML_BINARY}" > /dev/null
        then
            break
        fi

        WSH_YAML_BINARY="$( cd "$( dirname "${BASH_SOURCE[0]}" )" && pwd )/${YAML_TOOL}"
        if command -v "${WSH_YAML_BINARY}" > /dev/null
        then
            break
        fi

        WSH_YAML_TOOL=""
    done

    test -n "${WSH_YAML_TOOL}" || wsh_exit 20 "Cannot find gojq or yq."

    case "${WSH_YAML_TOOL}" in
        yq)   WSH_YAML_CMD=("${WSH_YAML_BINARY}" --indent "${WSH_INDENT}");;
        gojq) WSH_YAML_CMD=("${WSH_YAML_BINARY}" --yaml-input "--indent=${WSH_INDENT}");;
        *)    wsh_exit 21 "'${WSH_YAML_TOOL}' is not a valid yaml tool.";;
    esac
}


check_workspace()
{
    initialize_yaml_tool

    if [ ${#WSH_REPOLISTS[@]} -eq 0 ]
    then
        WSH_WORKSPACE_ROOT="$(realpath "${WSH_WORKSPACE_ROOT:-"./"}")/"
        WSH_REPOLIST="${WSH_WORKSPACE_ROOT}/.${WSH_WORKSPACE_TYPE}"
        if [ -d "${WSH_WORKSPACE_ROOT}" ]
        then
            test -f "${WSH_REPOLIST}" || discover_lists "${WSH_WORKSPACE_ROOT}" -maxdepth 1;
        fi
    fi

    if [ ${#WSH_REPOLISTS[@]} -eq 0 ] || [ "${WSH_REPOLISTS[0]}" = "" ]
    then
        # nothing has been found, WSH_REPOLIST points to a nonexistent file
        true
    elif [ ${#WSH_REPOLISTS[@]} -eq 1 ]
    then
        WSH_REPOLIST="${WSH_REPOLISTS[0]}"

        if [ -n "${WSH_WORKSPACE_ROOT}" ]
        then
            if [ "${WSH_REPOLISTS:0:1}" != "/" ]
            then
                WSH_REPOLIST="${WSH_WORKSPACE_ROOT}/${WSH_REPOLIST}"
            fi
        else
            WSH_WORKSPACE_ROOT="$(dirname "${WSH_REPOLIST}")"
        fi

        WSH_WORKSPACE_ROOT="$(realpath "${WSH_WORKSPACE_ROOT}")/"
    else
        WSH_WORKSPACE_ROOT="$(realpath "${WSH_WORKSPACE_ROOT:-"./"}")/"

        WSH_REPOLIST="${WSH_REPOLISTS[0]}"

        MERGE_DIR=${WSH_CACHE_DIR:-"${WSH_WORKSPACE_ROOT}/.wshandler"}
        WORKING_DIR="$(pwd)"

        mkdir -p "${MERGE_DIR}"
        rm -rf "${MERGE_DIR}/repolist"
        touch "${MERGE_DIR}/repolist"

        for REPOLIST in "${WSH_REPOLISTS[@]}"
        do
            test -f "${REPOLIST}" || wsh_exit 22 "Repository list '${REPOLIST}' does not exit.";

            REPOLIST_ROOT="$(realpath "$(dirname "${REPOLIST}")")/"
            cd "${WSH_WORKSPACE_ROOT}"
            RELATIVE_PATH=""
            while ! (echo "${REPOLIST_ROOT}" | grep "$(realpath "$(pwd)")" > /dev/null)
            do
                RELATIVE_PATH+="../"
                cd ..
            done
            RELATIVE_PATH="${RELATIVE_PATH}${REPOLIST_ROOT/#"$(realpath "$(pwd)")/"}"
            cd "${WORKING_DIR}"


            for SOURCE_TYPE in ${WSH_SOURCE_TYPES}
            do
                "${WSH_WORKSPACE_TYPE}_${WSH_YAML_TOOL}_repo_tuples" "${SOURCE_TYPE}" < "${REPOLIST}" \
                    | while read -r NAME REPO VERSION; \
                    do \
                        MERGE_NAME="${RELATIVE_PATH}${NAME}"; \
                        "${WSH_WORKSPACE_TYPE}_${WSH_YAML_TOOL}_remove" "${MERGE_NAME}" < "${MERGE_DIR}/repolist" \
                            | "${WSH_WORKSPACE_TYPE}_${WSH_YAML_TOOL}_add" \
                                "$(tuple_to_entry "${SOURCE_TYPE}" "${MERGE_NAME}" "${REPO}" "${VERSION}")" > "${MERGE_DIR}/repolist.merge"; \
                        mv "${MERGE_DIR}/repolist.merge" "${MERGE_DIR}/repolist"; \
                    done
            done

            WSH_REPOLIST="${MERGE_DIR}/repolist"
        done
    fi


    if [ ! -f "${WSH_REPOLIST}" ]
    then
        case $1 in
            scrape|add|init) touch "${WSH_REPOLIST}";;
            *)               wsh_exit 23 "'${WSH_REPOLIST}' is not a repository list";;
        esac
    fi
    WSH_REPOLIST=$(realpath "${WSH_REPOLIST}")


    WSH_CACHE_DIR=${WSH_CACHE_DIR:-"${WSH_WORKSPACE_ROOT}/.wshandler"}
    WSH_BACKUP_FILE="${WSH_CACHE_DIR}/repolist.back"

    test -d "${WSH_WORKSPACE_ROOT}" || (wsh_echo "'${WSH_WORKSPACE_ROOT}' does not exist" && false)

    WSHANDLER=("$(realpath "${BASH_SOURCE[0]}")" -l "${WSH_REPOLIST}" -y "${WSH_YAML_TOOL}" -Y "${WSH_YAML_BINARY}" -r "${WSH_WORKSPACE_ROOT}" -c "${WSH_CACHE_DIR}" -t "${WSH_WORKSPACE_TYPE}" -p "${WSH_COMMAND_POLICY}")
    if [ -n "${WSH_KEEP_GOING}" ]
    then
        WSHANDLER+=("${WSH_KEEP_GOING}")
    fi
}


backup()
{
    mkdir -p "${WSH_CACHE_DIR}"
    cp "${WSH_REPOLIST}" "${WSH_BACKUP_FILE}"
}


execute_command()
{
    for SOURCE_TYPE in ${WSH_SOURCE_TYPES}
    do
        wsh_echo ">>> $1: ${SOURCE_TYPE} sources ---"
        "$1" "${SOURCE_TYPE}" "${@:2}"
        wsh_echo "<<< $1: ${SOURCE_TYPE} sources ---"
    done
}


rosinstall_yq_repo_tuples()
{
    if [ ${#WSH_NAME_PATTERNS[@]} -gt 0 ]
    then
        SELECTION+="((.local-name | test(\"^${WSH_NAME_PATTERNS[0]}\$\"))"
        for NAME_PATTERN in "${WSH_NAME_PATTERNS[@]:1}";
        do
            SELECTION+=" or (.local-name | test(\"^${NAME_PATTERN}\$\"))"
        done
        SELECTION+=")"
    fi

    if [ ${#WSH_TAGS[@]} -gt 0 ]
    then
        if [ -n "${SELECTION}" ]
        then
            SELECTION+=" and "
        fi

        SELECTION+="(.wshandler.tags != null) and ((.wshandler.tags[] | . == \"${WSH_TAGS[0]}\")"
        for TAG in "${WSH_TAGS[@]:1}";
        do
            SELECTION+=" or (.wshandler.tags[] | . == \"${TAG}\")"
        done
        SELECTION+=")"
    fi

    if [ -z "${SELECTION}" ]
    then
        SELECTION="."
    fi

    "${WSH_YAML_CMD[@]}" ".[].$1 | select(${SELECTION}) | (.local-name + \" \" + .uri + \" \" + ((select(has(\"version\") and .version != null) // {\"version\": \"-\"}) | .version))"
}

rosinstall_gojq_repo_tuples()
{
    if [ ${#WSH_NAME_PATTERNS[@]} -gt 0 ]
    then
        SELECTION+="((.\"local-name\" | test(\"^${WSH_NAME_PATTERNS[0]}\$\"))"
        for NAME_PATTERN in "${WSH_NAME_PATTERNS[@]:1}";
        do
            SELECTION+=" or (.\"local-name\" | test(\"^${NAME_PATTERN}\$\"))"
        done
        SELECTION+=")"
    fi

    if [ ${#WSH_TAGS[@]} -gt 0 ]
    then
        if [ -n "${SELECTION}" ]
        then
            SELECTION+=" and "
        fi

        SELECTION+="(.wshandler.tags != null) and ((.wshandler.tags[] | . == \"${WSH_TAGS[0]}\")"
        for TAG in "${WSH_TAGS[@]:1}";
        do
            SELECTION+=" or (.wshandler.tags[] | . == \"${TAG}\")"
        done
        SELECTION+=")"
    fi

    if [ -z "${SELECTION}" ]
    then
        SELECTION="."
    fi

    "${WSH_YAML_CMD[@]}" --raw-output ".[].$1 | select(${SELECTION}) | \"\(.\"local-name\") \(.uri) \(.version // \"-\")\""
}

repos_yq_repo_tuples()
{
    SELECTION="(has(\"type\") and .type == \"$1\")"
    if [ ${#WSH_NAME_PATTERNS[@]} -gt 0 ]
    then
        SELECTION+=" and ((key | test(\"^${WSH_NAME_PATTERNS[0]}\$\"))"
        for NAME_PATTERN in "${WSH_NAME_PATTERNS[@]:1}";
        do
            SELECTION+=" or (key | test(\"^${NAME_PATTERN}\$\"))"
        done
        SELECTION+=")"
    fi

    if [ ${#WSH_TAGS[@]} -gt 0 ]
    then
        SELECTION+=" and (.wshandler.tags != null) and ((.wshandler.tags[] | . == \"${WSH_TAGS[0]}\")"
        for TAG in "${WSH_TAGS[@]:1}";
        do
            SELECTION+=" or (.wshandler.tags[] | . == \"${TAG}\")"
        done
        SELECTION+=")"
    fi

    "${WSH_YAML_CMD[@]}" ".repositories.* | select(. | ${SELECTION}) | (key + \" \" + .url + \" \" + ((select(has(\"version\") and .version != null) // {\"version\": \"-\"}) | .version))"
}

repos_gojq_repo_tuples()
{
    SELECTION="(.[\$k].type == \"$1\")"

    if [ ${#WSH_NAME_PATTERNS[@]} -gt 0 ]
    then
        SELECTION+=" and ((\$k | tostring | test(\"^${WSH_NAME_PATTERNS[0]}\$\"))"
        for NAME_PATTERN in "${WSH_NAME_PATTERNS[@]:1}";
        do
            SELECTION+=" or (\$k | tostring | test(\"^${NAME_PATTERN}\$\"))"
        done
        SELECTION+=")"
    fi

    if [ ${#WSH_TAGS[@]} -gt 0 ]
    then
        SELECTION+=" and (.[\$k].wshandler.tags != null) and ((.[\$k].wshandler.tags[] | . == \"${WSH_TAGS[0]}\")"
        for TAG in "${WSH_TAGS[@]:1}";
        do
            SELECTION+=" or (.[\$k].wshandler.tags[] | . == \"${TAG}\")"
        done
        SELECTION+=")"
    fi

    "${WSH_YAML_CMD[@]}" --raw-output ".repositories | keys[] as \$k | select(${SELECTION}) | \"\(\$k) \(.[\$k].url) \(.[\$k].version // \"-\")\""
}



rosinstall_yq_merge()
{
    REMOVE_LIST=$("${WSH_YAML_CMD[@]}" '.[].* | (".*.local-name == \"" +.local-name + "\" or ")' < "$1" | tr -d '\n' | sed -e 's/or $//')
    # shellcheck disable=SC2094
    { cat "$1"; "${WSH_YAML_CMD[@]}" "del(.[] | select(${REMOVE_LIST}))" < "$2" | "${WSH_YAML_CMD[@]}" 'del(. | select(length==0))'; }
}

rosinstall_gojq_merge()
{
    "${WSH_YAML_CMD[@]}" --slurp --yaml-output '.[0] + .[1] | unique_by(.[]."local-name")' "$1" "$2"
}

repos_yq_merge()
{
    # shellcheck disable=SC2016
    "${WSH_YAML_CMD[@]}" eval-all '. as $item ireduce ({}; . * $item)' <(cat "$2") <(cat "$1")
}

repos_gojq_merge()
{
    "${WSH_YAML_CMD[@]}" --slurp --yaml-output '.[1] * .[0]' "$1" "$2"
}


rosinstall_yq_sparse()
{
    "${WSH_YAML_CMD[@]}" ".[] | select(.*.local-name == \"$1\") | .git.wshandler.sparse[]" "$2" 2> /dev/null || return 0
}

rosinstall_gojq_sparse()
{
    "${WSH_YAML_CMD[@]}" --raw-output ".[] | select(.[].\"local-name\" == \"$1\") | .git.wshandler.sparse[]" "$2" 2> /dev/null || return 0
}

repos_yq_sparse()
{
    "${WSH_YAML_CMD[@]}" ".repositories.\"$1\".wshandler.sparse[]" "$2" 2> /dev/null || return 0
}

repos_gojq_sparse()
{
    "${WSH_YAML_CMD[@]}" --raw-output ".repositories.\"$1\".wshandler.sparse[]" "$2" 2> /dev/null || return 0
}


execute_merge()
{
    SECOND_FILE=$1
    if [ ! -s "${SECOND_FILE}" ] || [ "${WSH_REPOLIST}" -ef "${SECOND_FILE}" ]
    then
        help 10;
    fi
    if [ -s "${WSH_REPOLIST}" ]
    then
        case "${WSH_COMMAND_POLICY}" in
            keep|default)
                FIRST_FILE="${WSH_BACKUP_FILE}";;
            replace)
                FIRST_FILE="${SECOND_FILE}"
                SECOND_FILE="${WSH_BACKUP_FILE}";;
            *)
                help 11;;
        esac
        backup
        "${WSH_WORKSPACE_TYPE}_${WSH_YAML_TOOL}_merge" "${FIRST_FILE}" "${SECOND_FILE}" > "${WSH_REPOLIST}"
    else
        cp "${SECOND_FILE}" "${WSH_REPOLIST}"
    fi
}


rosinstall_yq_remove()
{
    "${WSH_YAML_CMD[@]}" "del(.[] | select(.*.local-name == \"$1\"))"
}

rosinstall_gojq_remove()
{
    "${WSH_YAML_CMD[@]}" --yaml-output "del(.[] | select(.[].\"local-name\" == \"$1\"))"
}

repos_yq_remove()
{
    "${WSH_YAML_CMD[@]}" "del(.repositories.\"$1\")"
}

repos_gojq_remove()
{
    "${WSH_YAML_CMD[@]}" --yaml-output "del(.repositories.\"$1\")"
}


rosinstall_yq_remove_by_url()
{
    "${WSH_YAML_CMD[@]}" "del(.[] | select(.*.uri == \"$1\"))"
}

rosinstall_gojq_remove_by_url()
{
    "${WSH_YAML_CMD[@]}" --yaml-output "del(.[] | select(.[].uri == \"$1\"))"
}

repos_yq_remove_by_url()
{
    "${WSH_YAML_CMD[@]}" "del(.repositories.* | select(.url == \"$1\"))"
}

repos_gojq_remove_by_url()
{
    "${WSH_YAML_CMD[@]}" --yaml-output "del(.repositories.[] | select(.url == \"$1\"))"
}


rosinstall_yq_add()
{
    "${WSH_YAML_CMD[@]}" ". + $1"
}

rosinstall_gojq_add()
{
    "${WSH_YAML_CMD[@]}" --null-input --yaml-output "input? // [] | . + $1"
}

repos_yq_add()
{
    "${WSH_YAML_CMD[@]}" ". * {\"repositories\": $1}"
}

repos_gojq_add()
{
    "${WSH_YAML_CMD[@]}" --null-input --yaml-output "input? // {} | . * {\"repositories\": $1}"
}

tuple_to_entry()
{
    case ${WSH_WORKSPACE_TYPE} in
        rosinstall) echo "[{\"$1\": {\"local-name\": \"$2\", \"uri\": \"$3\", \"version\": \"$4\"}}]";;
        repos)      echo "{\"$2\": {\"type\": \"$1\", \"url\": \"$3\", \"version\": \"$4\"}}";;
    esac
}

execute_add()
{
    backup
    "${WSH_WORKSPACE_TYPE}_${WSH_YAML_TOOL}_remove" "$2" < "${WSH_BACKUP_FILE}" | "${WSH_WORKSPACE_TYPE}_${WSH_YAML_TOOL}_add" "$(tuple_to_entry "$@")" > "${WSH_REPOLIST}"
}


dir_run()
{
    wsh_echo "Processing '$1'"
    if [ -d "${WSH_WORKSPACE_ROOT}/$1/" ]
    then
        cd "${WSH_WORKSPACE_ROOT}/$1/" && sh -c "$2"
    else
        wsh_echo "Missing directory: ${WSH_WORKSPACE_ROOT}/$1/"
    fi
}

execute_foreach()
{
    "${WSH_WORKSPACE_TYPE}_${WSH_YAML_TOOL}_repo_tuples" "$1" < "${WSH_REPOLIST}" | cut -f 1 -d ' ' | "${WSH_XARGS[@]}" -I {} "${WSHANDLER[@]}" dir_run "{}" "$2"
}

execute_branch()
{
    ACTION=$1
    BRANCH=$2

    case ${ACTION} in
        new)
            execute_foreach git "((git status --porcelain | grep . > /dev/null) && git checkout -b '${BRANCH}') || true";;
        allnew)
            execute_foreach git "git checkout -b '${BRANCH}'";;
        delete)
            execute_foreach git "(git ls-remote --exit-code --heads origin '${BRANCH}' > /dev/null && git push origin --delete '${BRANCH}') || true";;
        show)
            execute_foreach git "git branch -a | grep '${BRANCH}'";;
        merge)
            TARGET_BRANCH=${3:-"main"}
            "${WSH_WORKSPACE_TYPE}_${WSH_YAML_TOOL}_repo_tuples" git < "${WSH_REPOLIST}" | cut -f 1 -d ' ' | while read -r NAME; do dir_git_merge "${NAME}" "${BRANCH}" "${TARGET_BRANCH}"; done
            ;;
        *) help 1;;
    esac
}

execute_commit()
{
    execute_foreach git "((git status --porcelain | grep . > /dev/null) && git commit -a -m '${1}') || true"
}

execute_clone()
{
    "$1_clone" "NO" "$2" "$3" "${WSH_WORKSPACE_ROOT}"

    execute_selective_command update
}

execute_init()
{
    mkdir -p "${WSH_WORKSPACE_ROOT}"

    if [ "$1" == "git" ]
    then
        shift
        pushd "${WSH_WORKSPACE_ROOT}" > /dev/null
        while [[ $# -gt 0 ]]
        do
            git_clone "NO" "$1"
            shift
        done
        popd > /dev/null

        check_workspace init
        "${WSHANDLER[@]}" -p add scrape
    else
        check_workspace init
    fi
}

execute_selective_command()
{
    COMMAND_NAME="$1"
    WSH_NAME_PATTERNS=("${@:2}")
    # strip trailing slashes
    WSH_NAME_PATTERNS=("${WSH_NAME_PATTERNS[@]%/}")

    check_workspace "${COMMAND_NAME}"

    if [ "${COMMAND_NAME}" == "update" ] && [ ${#WSH_NAME_PATTERNS[@]} -eq 0 ]
    then
        update_root
    fi

    for SOURCE_TYPE in ${WSH_SOURCE_TYPES}
    do
        case ${COMMAND_NAME} in
            clean|update)
                "${WSH_WORKSPACE_TYPE}_${WSH_YAML_TOOL}_repo_tuples" "${SOURCE_TYPE}" < "${WSH_REPOLIST}" \
                    | "${WSH_XARGS[@]}" -n 3 "${WSHANDLER[@]}" "dir_${SOURCE_TYPE}_${COMMAND_NAME}";;
            *)
                "${WSH_WORKSPACE_TYPE}_${WSH_YAML_TOOL}_repo_tuples" "${SOURCE_TYPE}" < "${WSH_REPOLIST}" \
                    | "${WSH_XARGS[@]}" -n 3 "${WSHANDLER[@]}" "dir_${SOURCE_TYPE}" "${COMMAND_NAME}";;
        esac
    done
}

set_version()
{
    TARGET_MATCH="$2"
    TARGET_VERSION="$3"

    case $1 in
        set_version_by_url) TYPE=REPO;;
        set_version_by_name) TYPE=NAME;;
        *) TYPE=ALL;;
    esac

    UPDATED=NO
    for SOURCE_TYPE in ${WSH_SOURCE_TYPES}
    do
        while read -r NAME REPO VERSION;
        do
            if [ "${TYPE}" = "ALL" ];
            then
                cd "${WSH_WORKSPACE_ROOT:?}/${NAME}";
                case $1 in
                    set_version_to_hash|pin) TARGET_VERSION="$("dir_${SOURCE_TYPE}_get_hash")";;
                    set_version_to_branch)
                        case "${WSH_COMMAND_POLICY}" in
                            default|active)
                                if [ "${TARGET_MATCH}" != "$("dir_${SOURCE_TYPE}_get_branch")" ];
                                then
                                    continue;
                                fi;;
                            *) exit 60;;
                        esac
                        TARGET_VERSION="${TARGET_MATCH}";
                        ;;
                esac
            elif [ "${TARGET_MATCH}" != "${!TYPE}" ];
            then
                continue;
            fi;
            UPDATED=YES;
            if [ "${VERSION}" != "${TARGET_VERSION}" ];
            then
                wsh_echo "${NAME}: changing '${VERSION}' to '${TARGET_VERSION}'";
                execute_add "${SOURCE_TYPE}" "${NAME}" "${REPO}" "${TARGET_VERSION}";
            fi;
            test "${TYPE}" == "ALL" || exit 0;
        done < <("${WSH_WORKSPACE_TYPE}_${WSH_YAML_TOOL}_repo_tuples" "${SOURCE_TYPE}" < "${WSH_REPOLIST}")
    done

    test "${UPDATED}" = "YES" || wsh_exit 61 "Nothing to update."
}

discover_lists()
{
    DISCOVER_PATH=$(realpath "$1");
    readarray -t WSH_REPOLISTS <<< "$(find "${DISCOVER_PATH}" "$@" -iname "*.${WSH_WORKSPACE_TYPE}" | sort)";
}


apt_install()
{
    sudo env DEBIAN_FRONTEND=noninteractive apt --yes --no-install-recommends install "$@"
}

snap_install()
{
    sudo snap install "$@"
}

wsh_download()
{
    command -v "wget" > /dev/null || apt_install wget 1>&2
    wget -O - "$@"
}


WSH_YAML_TOOL="auto"
WSH_SOURCE_TYPES="git"
WSH_COMMAND_POLICY=default
WSH_JOBS=1
WSH_INDENT=4
WSH_XARGS=(xargs --no-run-if-empty -P "${WSH_JOBS}")
WSH_KEEP_GOING=""
WSH_YAML_BINARY=
WSH_REPOLIST=
WSH_REPOLISTS=()
WSH_REPOLIST_SOURCE=
WSH_SORT_COMMAND="sort"
WSH_BACKUP_FILE=
WSH_TAGS=()
WSH_UNMANAGED=NO
WSH_QUIET=NO
WSH_WORKSPACE_TYPE=repos

while [[ $# -gt 0 ]]
do
    case $1 in
        -v|--version)
            if [ -n "${WSH_VERSION}" ]
            then
                wsh_exit 0 "wshandler version: ${WSH_VERSION}"
            else
                wsh_exit 50 "wshandler version is unknown"
            fi;;

        -y|--yaml_tool)   WSH_YAML_TOOL="$2";                         shift; shift;;
        -Y|--yaml_binary) WSH_YAML_BINARY=$2;                         shift; shift;;
        -r|--root)        WSH_WORKSPACE_ROOT=$2;                      shift; shift;;
        -c|--cache)       WSH_CACHE_DIR=$2;                           shift; shift;;
        -t|--type)        WSH_WORKSPACE_TYPE=$2;                      shift; shift;;
        -j|--jobs)        WSH_JOBS=$2; WSH_XARGS+=(-P "${WSH_JOBS}"); shift; shift;;
        -i|--indent)      WSH_INDENT=$2;                              shift; shift;;
        -p|--policy)      WSH_COMMAND_POLICY=$2;                      shift; shift;;

        -k|--keep-going)  WSH_KEEP_GOING="-k";                        shift;;
        -T|--tag)         WSH_TAGS+=("$2");                           shift; shift;;
        -u|--unsorted)    WSH_SORT_COMMAND="cat";                     shift;;
        -U|--unmanaged)   WSH_UNMANAGED="YES";                        shift;;
        -q|--quiet)       WSH_QUIET="YES";                            shift;;

        -l|--list)
            test "${WSH_REPOLIST_SOURCE}" != "-L" || wsh_exit 7 "Arguments -l and -L are incompatible.";
            WSH_REPOLIST_SOURCE="-l";
            WSH_REPOLISTS+=("$2");
            shift; shift;;
        -L|--list-discover)
            test "${WSH_REPOLIST_SOURCE}" != "-l" || wsh_exit 7 "Arguments -l and -L are incompatible.";
            WSH_REPOLIST_SOURCE="-L";
            discover_lists "${WSH_WORKSPACE_ROOT:-"./"}";
            shift;;

        clone|init)
            "execute_$1" "${@:2}"
            exit;;

        status|scrape)
            check_workspace "$1"
            if [ -z "$2" ]
            then
                execute_command "$1" "${WSH_WORKSPACE_ROOT}"
            else
                execute_command "${@}"
            fi
            exit;;

        clean|update|unshallow|prune|push|feature_branches)
            if [ "${WSH_UNMANAGED}" == "NO" ]
            then
                execute_selective_command "${@}"
            else
                initialize_yaml_tool
                for DIR in "${@:2}";
                do
                    # repo types may be mixed, process one by one
                    if [ -d "${DIR}/.git" ]
                    then
                        wsh_echo "Processing '${DIR}'"
                        case $1 in
                            clean|update)   "dir_git_$1" "${DIR}" "-" "-"   ;;
                            *)              "dir_git" "$1" "${DIR}" "-" "-" ;;
                        esac
                    else
                        wsh_exit 8 "Unmanaged handling is supported for git repositories only."
                    fi
                done
            fi
            exit;;

        is_source_space)
            WSH_QUIET=YES
            check_workspace "is_source_space"
            exit;;

        add|merge|foreach|branch|commit)
            check_workspace "$1"
            "execute_$1" "${@:2}"
            exit;;

        remove|remove_by_url)
            check_workspace "$1"
            for PKG_ID in "${@:2}"
            do
                backup
                "${WSH_WORKSPACE_TYPE}_${WSH_YAML_TOOL}_$1" "${PKG_ID}" < "${WSH_BACKUP_FILE}" > "${WSH_REPOLIST}"
            done
            exit;;

        set_version_by_url|set_version_by_name|set_version_to_hash|set_version_to_branch|pin)
            check_workspace "$1"
            set_version "${@}"
            exit;;

        dir_*_update|dir_run)
            initialize_yaml_tool
            if [ -n "${WSH_KEEP_GOING}" ]
            then
                "$1" "${@:2}" || true
            else
                "$1" "${@:2}"
            fi
            exit;;

        dir_*)
            "$1" "${@:2}"
            exit;;

        install_test_deps)
            apt_install shellcheck
            exit;;

        install)
            BIN_PATH=${2:-"${HOME}/bin"}

            mkdir -p "${BIN_PATH}"
            if [ ! "${BASH_SOURCE[0]}" -ef "${BIN_PATH}/wshandler" ]
            then
                cp "${BASH_SOURCE[0]}" "${BIN_PATH}/wshandler"
            fi

            case "${WSH_COMMAND_POLICY}" in
                skip_yaml_tool|yq_skip|default) exit;;
            esac

            if [ -z "${WSH_YAML_BINARY}" ]
            then
                WSH_YAML_BINARY="${WSH_YAML_TOOL}"
            fi

            if ! command -v "${WSH_YAML_BINARY}" > /dev/null
            then
                case ${WSH_YAML_TOOL} in
                    yq)
                        case "${WSH_COMMAND_POLICY}" in
                            snap)
                                command -v "snap" > /dev/null || apt_install snap
                                snap_install yq
                                ;;
                            download)
                                wsh_download "https://github.com/mikefarah/yq/releases/latest/download/yq_linux_$(dpkg --print-architecture)" > "${BIN_PATH}/yq"
                                chmod +x "${BIN_PATH}/yq"
                                ;;
                            *)
                                wsh_exit 4 "Unsupported installation policy.";;
                        esac;;
                    gojq)
                        case "${WSH_COMMAND_POLICY}" in
                            apt) apt_install gojq;;
                            *)   wsh_exit 5 "Unsupported installation policy.";;
                        esac;;
                    auto)
                        wsh_exit 6 "Automatic yaml tool detection is not supported for this command.";;
                esac
            fi
            exit;;

        upgrade)
            BIN_PATH=${2:-"${HOME}/bin"}
            mkdir -p "${BIN_PATH}"

            wsh_download "https://github.com/asherikov/wshandler/releases/latest/download/wshandler" > "${BIN_PATH}/wshandler"
            chmod +x "${BIN_PATH}/wshandler"
            exit;;

        upgrade_appimage)
            BIN_PATH=${2:-"${HOME}/bin"}
            mkdir -p "${BIN_PATH}"

            wsh_download "https://github.com/asherikov/wshandler/releases/latest/download/wshandler-yq-$(uname -m).AppImage" > "${BIN_PATH}/wshandler"
            chmod +x "${BIN_PATH}/wshandler"
            exit;;

        *)
            help 1;;
    esac
done

help 2
