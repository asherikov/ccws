Why?
====

- Target platforms usually have limited resources compared to the development
  PCs (CPU, memory), which makes compilation much slower.

- The required amount of target platforms may not be available.

- Keeping build envoronment on target platforms may be undesirable due to
  limited resources or security considerations.


Why not qemu?
=============

A common approach is to use 'cross-compilation' with qemu, which is in fact a
native build in emulation. It avoids many cross-compilation issues, but is
much, roughly 8 times, slower. The exact tool used for isolation (`docker`,
`chroot`) is irrelevant -- the main cost is the emulation. Build caches such as
`ccache` are helpful but sometimes not sufficient. Another viable option is to
use prebuild binary packages, compile only a small subset of project packages
at a time, and rely on ROS package overlay mechanics -- this however involves
much more micro management from developers, which may not have required skills
or time.


Issues with 'true' cross-compilation
====================================

The main difficulty is that many ROS and non-ROS cmake packages use hardcoded
absolute paths to include files and libraries, which therefore cannot be found
in the target system root and are searched in the host system instead. For
example something like `include_directories(/usr/include)` is impossible to fix
on the project scale: this command is evaluated to `-I/usr/include`, which can
only be overriden by `-I${SYSROOT}/usr/include`, but then the packages that use
strict compilation flags and `include_directories(SYSTEM /usr/include)` are
going to fail. ROS2 addresses this issue in the new `ament` system which
replaced `catkin`, but its wide adoption is not going to happen for a while.

Another issue is that the paths in `cmake` config files generated by catkin for
cross-compiled packages are going to be messed up as well if you are not
installing them to the host system.


Goal
====

Ideally we are looking for a solution that would trick the build system into
believing that target root is the actual root, while using host native binaries
during compilation.

This would require 'chrooting' into the target root, mounting host binaries to
a subfolder, and then using environment variables to override binary paths.
Ironically, ROS build process also involves execution of scripts that include
hardcoded absolute paths to system utilities, e.g., `/usr/bin/env`, which means
that we have be able to run both host and target binaries or override target
binaries.


chroot, schroot, fakechroot
===========================

`chroot` and `fakechroot` have issues with supporting both host and target
binaries, `chroot` works fine with target binaries, `fakechroot` -- with host
binaries. `schroot` is just `chroot` + helper scripts. So far I couldn't find a
way to make these work, may be there is a way with `binfmt` magic.

`fakechroot` also has issues with absolute symlinks, which must be changed to
relative.


proot
=====

`proot` is a cross-compilation tool designed with our use-case in mind, and it
works pretty much out of the box. The performance is not fascinating though --
2-3 times slower than native build.


docker, systemd-nspawn
======================

Seem to be no different from `chroot` for this purpose.


Alternatives
============

- Do cross-compilation with compiler/linker wrappers that would fix paths
  specified in compiler parameters. It may be necessary to write scripts to
  patch cmake config files as well.
